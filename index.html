<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Air Speed - KARTA</title>
  
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <!-- MarkerCluster CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />

  <style>
    /* Global Button styling */
    button {
      background-color: #4caf50;
      border: none;
      color: white;
      padding: 10px 20px;
      font-size: 14px;
      margin: 5px 2px;
      cursor: pointer;
      border-radius: 5px;
      transition: background-color 0.3s ease, transform 0.2s ease;
    }
    button:hover {
      background-color: #45a049;
      transform: scale(1.05);
    }
    /* Basic Page & Map Styling */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
    }
    #map {
      height: 100vh;
      width: 100%;
    }
    .leaflet-div-icon {
      background: transparent !important;
      border: none !important;
      box-shadow: none !important;
    }
    /* Notification Container */
    #notificationContainer {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 20000;
    }
    .notification {
      margin-bottom: 5px;
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      color: #fff;
      opacity: 0.9;
      transition: opacity 0.5s ease;
    }
    .notification.success {
      background-color: #4caf50;
    }
    .notification.error {
      background-color: #f44336;
    }
    /* Authentication Overlay */
    #auth-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.95);
      z-index: 30000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #auth-container h2 {
      margin-bottom: 10px;
    }
    #auth-container form {
      margin-bottom: 10px;
    }
    #auth-container input {
      padding: 8px;
      margin: 4px 0;
      width: 250px;
      box-sizing: border-box;
    }
    /* SIDEBAR CONTAINER: groups pin list only */
    #sidebarContainer {
      position: absolute;
      top: 15%;
      left: 10px;
      z-index: 10000;
    }
    /* LEFT SIDE PIN LIST STYLING */
    #pinListMenu {
      width: 220px;
      height: 300px;
      background: rgba(255, 255, 255, 0.5);
      border: 1px solid #ccc;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      border-radius: 4px;
      overflow-y: auto;
      padding: 5px;
      font-size: 14px;
      box-sizing: border-box;
      position: relative;
    }
    /* Resizer on right edge */
    #pinListResizer {
      position: absolute;
      top: 0;
      right: 0;
      width: 5px;
      height: 100%;
      cursor: ew-resize;
      background: transparent;
      z-index: 10001;
    }
    #pinListResizer:hover {
      background: #aaa;
    }
    /* Pin list items (flex layout) */
    .pin-list-item {
      display: flex;
      align-items: center;
      padding: 2px 5px;
      border-bottom: 1px solid #ccc;
      transition: background-color 0.2s ease;
    }
    .pin-list-item:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }
    /* Combined marker (icon + pin number) styling */
    .pin-icon-number {
      display: inline-block;
      margin-right: 5px;
      font-size: 10px;
      font-weight: bold;
      color: white;
      border: 2px solid rgba(255, 255, 255, 0.8);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      line-height: 15px;
      width: 15px;
      height: 15px;
      text-align: center;
      transition: transform 0.2s ease;
    }
    /* Pin text styling – if tooltip is off, the inline style will add strikethrough */
    .pin-text {
      flex: 1;
      white-space: pre;
      overflow: hidden;
      text-overflow: clip;
    }
    /* SEARCH and LAYER selectors */
    #searchContainer {
      position: absolute;
      top: 10px;
      left: 50px;
      z-index: 10001;
      width: 80%;
      max-width: 375px;
    }
    #searchBar {
      width: 100%;
      padding: 8px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box;
      transition: box-shadow 0.3s ease;
    }
    #searchBar:focus {
      outline: none;
      box-shadow: 0 0 5px rgba(81, 203, 238, 1);
      border-color: rgba(81, 203, 238, 1);
    }
    #searchResults {
      list-style: none;
      margin: 0;
      padding: 0;
      background: white;
      border: 1px solid #ccc;
      border-radius: 4px;
      max-height: 150px;
      overflow-y: auto;
      display: none;
    }
    #searchResults li {
      padding: 5px;
      cursor: pointer;
    }
    #searchResults li:hover {
      background: #f0f0f0;
    }
    #layerSelectContainer {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10001;
    }
    #layerSelectContainer select {
      padding: 5px;
      font-size: 14px;
    }
    #layerButtons {
      display: inline-block;
      margin-left: 30px;
    }
    /* Modal for Custom Pin Form */
    #pinFormModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 10000;
      align-items: center;
      justify-content: center;
    }
    #pinFormModal .modal-content {
      background: #fff;
      padding: 20px;
      border-radius: 12px;
      width: 90%;
      max-width: 320px;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
    }
    #pinFormModal label {
      font-weight: bold;
    }
    #pinFormModal input[type="text"],
    #pinFormModal textarea {
      width: 100%;
      margin-bottom: 10px;
      box-sizing: border-box;
    }
    /* Icon Custom Options Layout */
    #iconCustomOptions {
      display: flex;
      flex-direction: row;
      margin-bottom: 10px;
    }
    #shapeSelection {
      padding-right: 5px;
      border-right: 1px solid #ccc;
    }
    .shape-option {
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 5px;
      cursor: pointer;
      border: 1px solid #ccc;
    }
    #colorSelection {
      padding: 0 5px;
      border-right: 1px solid #ccc;
    }
    #colorSelection table {
      border-collapse: collapse;
    }
    #colorSelection td {
      padding: 0;
      margin: 0;
    }
    .color-option {
      width: 15px;
      height: 15px;
      cursor: pointer;
      border: 1px solid #ccc;
      display: inline-block;
    }
    #iconPreview {
      padding-left: 5px;
    }
    #previewWindow {
      width: 100px;
      height: 100px;
      border: 1px solid #ccc;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .selected {
      border-color: orange !important;
    }
    /* Enhanced Marker styling for map icons */
    .custom-marker {
      font-size: 10px;
      font-weight: bold;
      color: white;
      border: 2px solid rgba(255, 255, 255, 0.8);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    .custom-marker:hover {
      transform: scale(1.2);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    }
    /* Tooltip styling */
    .custom-tooltip {
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 5px;
      border-radius: 3px;
      font-size: 12px;
    }
    /* Context Menu Styling */
    .custom-context-menu {
      text-align: center;
      font-size: 14px;
    }
    .custom-context-menu a {
      display: block;
      padding: 6px 10px;
      color: #333;
      text-decoration: none;
      border-bottom: 1px solid #eee;
    }
    .custom-context-menu a:last-child {
      border-bottom: none;
    }
    .custom-context-menu a:hover {
      background-color: #f9f9f9;
      color: #000;
    }
    /* Style for Toggle Button moved to bottom left */
    #toggleAllUtovare {
      position: fixed;
      bottom: 10px;
      left: 10px;
      z-index: 10000;
    }
    /* Responsive styles */
    @media (max-width: 768px) {
      #sidebarContainer {
        top: 5%;
        left: 5px;
      }
      #pinListMenu {
        width: 180px;
        height: 250px;
      }
      #searchContainer {
        left: 10%;
        width: 90%;
      }
      #layerSelectContainer {
        top: 5px;
      }
      #pinFormModal .modal-content {
        width: 95%;
        max-width: 280px;
      }
    }
  </style>
  
  <!-- Telematics API Libraries -->
  <script src="https://app.nts-international.net/com/nts/js/nts-jwt.js"></script>
  <script src="https://app.nts-international.net/com/nts/js/nts-api.js"></script>
  
  <!-- Leaflet & MarkerCluster JS -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
  
  <!-- Firebase SDKs -->
  <script src="https://www.gstatic.com/firebasejs/9.19.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.19.0/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.19.0/firebase-auth-compat.js"></script>
  
  <!-- Override XMLHttpRequest to automatically add the required header for NTS API -->
  <script>
    (function() {
      const originalOpen = XMLHttpRequest.prototype.open;
      XMLHttpRequest.prototype.open = function(method, url, async, user, password) {
         this.withCredentials = true;
         this._ntsUrl = url;
         return originalOpen.call(this, method, url, async, user, password);
      };
      const originalSend = XMLHttpRequest.prototype.send;
      XMLHttpRequest.prototype.send = function(data) {
         if (this._ntsUrl && this._ntsUrl.includes("app.nts-international.net")) {
           try {
             this.setRequestHeader("nts-application", "nts-rest-api");
           } catch(e) {
             console.error("Error setting nts-application header:", e);
           }
         }
         return originalSend.call(this, data);
      };
    })();
  </script>
</head>
<body>
  <!-- Notification Container -->
  <div id="notificationContainer"></div>
  
  <!-- Authentication Overlay -->
  <div id="auth-container">
    <div id="signInContainer">
      <h2>Sign In</h2>
      <form id="signInForm">
        <input type="email" id="signInEmail" placeholder="Email" required />
        <input type="password" id="signInPassword" placeholder="Šifra" required />
        <button type="submit">Sign In</button>
      </form>
    </div>
  </div>
  
  <!-- Sidebar: Pin List -->
  <div id="sidebarContainer">
    <div id="pinListMenu">
      <div id="pinListContent"></div>
      <div id="pinListResizer"></div>
    </div>
  </div>
  
  <!-- Toggle Button (positioned in the bottom left corner) -->
  <button id="toggleAllUtovare">Otvori sve utovare</button>
  
  <!-- Search Container -->
  <div id="searchContainer">
    <input type="text" id="searchBar" placeholder="Pronađi lokaciju..." />
    <ul id="searchResults"></ul>
  </div>
  
  <!-- Layer Selector -->
  <div id="layerSelectContainer">
    <select id="pinLayerSelect"></select>
    <div id="layerButtons">
      <button id="renameLayerBtn">Preimenuj</button>
      <button id="exportLayerBtn">Sačuvaj</button>
      <button id="importLayerBtn">Dodaj</button>
      <button id="deleteLayerBtn">Obriši</button>
    </div>
  </div>
  
  <!-- Map Container -->
  <div id="map"></div>
  
  <!-- Hidden File Input for Import -->
  <input type="file" id="importLayerInput" style="display: none;" accept="application/json" />
  
  <!-- Modal for Custom Pin Form -->
  <div id="pinFormModal">
    <div class="modal-content">
      <h3 id="modalHeader"></h3>
      <label for="pinTitle">Nalogodavac:</label>
      <input type="text" id="pinTitle" placeholder="Naziv firme" required />
      <label for="pinNumber">Kamion (optional):</label>
      <input type="text" id="pinNumber" placeholder="Oznaka kamiona" />
      <label for="pinDescription">Detalji:</label>
      <textarea id="pinDescription" placeholder="Količina, težina.."></textarea>
      <!-- Icon Options Layout -->
      <div id="iconCustomOptions">
        <div id="shapeSelection">
          <div class="shape-option" data-shape="square">
            <div style="width:30px; height:30px; border:1px solid gray;"></div>
          </div>
          <div class="shape-option" data-shape="circle">
            <div style="width:30px; height:30px; border:1px solid gray; border-radius:50%;"></div>
          </div>
        </div>
        <div id="colorSelection">
          <!-- Color table will be generated dynamically -->
        </div>
        <div id="iconPreview">
          <div id="previewWindow"></div>
        </div>
      </div>
      <button id="savePinBtn">Dodaj</button>
      <button id="cancelPinBtn">Otkaži</button>
    </div>
  </div>
  
  <!-- Main JavaScript Code -->
  <script>
    /* Firebase Config & Initialization */
    const firebaseConfig = {
      apiKey: "AIzaSyDXfhDG2NhylapRByYpE5leAEuIiyHPdBQ",
      authDomain: "nts-air.firebaseapp.com",
      databaseURL: "https://nts-air.firebaseio.com",
      projectId: "nts-air",
      storageBucket: "nts-air.firebasestorage.app",
      messagingSenderId: "690931555767",
      appId: "1:690931555767:web:506a87b24fad77653f1c32",
      measurementId: "G-7HNTMVW7Z9"
    };
    firebase.initializeApp(firebaseConfig);
    
    // Notification helper
    function showNotification(message, type) {
      const container = document.getElementById("notificationContainer");
      const notif = document.createElement("div");
      notif.className = "notification " + (type || "success");
      notif.textContent = message;
      container.appendChild(notif);
      setTimeout(() => {
        notif.style.opacity = 0;
        setTimeout(() => { container.removeChild(notif); }, 500);
      }, 3000);
    }
    
    // Authentication: Sign In
    const signInForm = document.getElementById("signInForm");
    signInForm.addEventListener("submit", function(e) {
      e.preventDefault();
      const email = document.getElementById("signInEmail").value;
      const password = document.getElementById("signInPassword").value;
      firebase.auth().signInWithEmailAndPassword(email, password)
        .then(userCredential => {
          showNotification("Signed in as " + userCredential.user.email, "success");
        })
        .catch(error => {
          showNotification("Sign-In Error: " + error.message, "error");
        });
    });
    
    firebase.auth().onAuthStateChanged(function(user) {
      if (user) {
        document.getElementById("auth-container").style.display = "none";
        console.log("User signed in:", user.email, user.uid);
        initMapAndRealtime();
      } else {
        document.getElementById("auth-container").style.display = "flex";
        console.log("No user signed in.");
      }
    });
    
    // Debounce utility
    function debounce(func, delay) {
      let timeout;
      return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), delay);
      };
    }
    
    // Global variable for file saving
    let saveFolderHandle = null;
    async function saveFile(data, fileName) {
      if (!window.showDirectoryPicker) {
        alert("File System Access API is not supported in this browser.");
        return;
      }
      if (!saveFolderHandle) { 
        saveFolderHandle = await window.showDirectoryPicker(); 
      }
      const kartaHandle = await saveFolderHandle.getDirectoryHandle("Karta", { create: true });
      const fileHandle = await kartaHandle.getFileHandle(fileName, { create: true });
      const writableStream = await fileHandle.createWritable();
      await writableStream.write(data);
      await writableStream.close();
      alert("File saved successfully to Documents/Karta as " + fileName);
    }
    
    /************ Telematics Integration & Map Setup ************/
    // Manual login function using fetch
    function performNTSLogin(ccodeAndApiUsername, password, callback) {
      const endpoint = "http://app.nts-international.net/NTSSecurity/login";
      const basicAuth = "Basic " + btoa(ccodeAndApiUsername + ":" + password);
      fetch(endpoint, {
        method: 'POST',
        headers: {
          'Authorization': basicAuth,
          'nts-application': 'nts-rest-api'
        },
        credentials: 'include'
      })
      .then(response => {
        if (!response.ok) {
          throw new Error("Login failed with status " + response.status);
        }
        return response.text();
      })
      .then(data => {
        console.log("Telematics API login successful!", data);
        callback();
      })
      .catch(error => {
        console.error("Telematics API login error:", error);
        showNotification("Telematics API login failed: " + error.message, "error");
      });
    }
    
    function initMapAndRealtime() {
      const map = L.map("map", { center: [45.541, 10.211], zoom: 7 });
      const baseLayer = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: "Map data © OpenStreetMap contributors"
      });
      baseLayer.addTo(map);
      
      const vehicleLayer = L.markerClusterGroup();
      const customPinLayer = L.layerGroup();
      vehicleLayer.addTo(map);
      customPinLayer.addTo(map);
      L.control.layers({ "Base Map": baseLayer }, { "Vozila": vehicleLayer, "Utovari": customPinLayer }).addTo(map);
      
      /***** NTS Telematics API Integration *****/
      const ccodeAndApiUsername = "t0190-transporeon.api"; // Format: ccode-apiusername
      const tsPassword = "airspeed2024";
      performNTSLogin(ccodeAndApiUsername, tsPassword, function() {
        // After login, instantiate the NTS API object.
        window.api = new NTSApi("http://app.nts-international.net");
        
        // Function to fetch vehicle data; appending ?version=2 returns full data.
        function updateVehiclesFromTelematics() {
          vehicleLayer.clearLayers();
          console.log("Fetching all vehicles...");
          api.allvehicles(function(vehicles) {
            console.log("All vehicles response:", vehicles);
            if (!vehicles || !Array.isArray(vehicles)) {
              console.warn("No vehicles returned or response not an array.");
              return;
            }
            vehicles.forEach(vehicle => {
              console.log("Processing vehicle with id:", vehicle.id);
              api.vehiclestate(vehicle.id, "UTC", 2, false, false, function(state) {
                console.log("Vehicle state for id", vehicle.id, ":", state);
                if (state && state.gpsLat && state.gpsLon) {
                  const marker = L.marker([state.gpsLat, state.gpsLon]).bindPopup("Vehicle ID: " + vehicle.id);
                  vehicleLayer.addLayer(marker);
                } else {
                  console.warn("No valid GPS data for vehicle id:", vehicle.id);
                }
              });
            });
          });
        }
        updateVehiclesFromTelematics();
        setInterval(updateVehiclesFromTelematics, 60000);
      });
      
      /***** Firebase Realtime Database Integration & Custom Pin Management *****/
      let pinLayers = [];
      let activePinLayerId = null;
      let activePinLayer = null;
      let customPins = [];
      
      function savePinLayersToDatabase() {
        firebase.database().ref("globalMapPinLayers").set(pinLayers, function (error) {
          if (error) {
            showNotification("Error saving data: " + error, "error");
          } else {
            showNotification("Changes saved", "success");
          }
        });
      }
      
      function loadPinLayersFromDatabase() {
        firebase.database().ref("globalMapPinLayers").on("value", function (snapshot) {
          const data = snapshot.val();
          if (data) {
            pinLayers = data;
          } else {
            const defaultLayer = { id: "layer_default", name: ". nedelja", pins: [] };
            pinLayers = [defaultLayer];
            activePinLayerId = defaultLayer.id;
            savePinLayersToDatabase();
          }
          if (!activePinLayerId) {
            activePinLayerId = pinLayers[0].id;
          }
          activePinLayer = pinLayers.find(layer => layer.id === activePinLayerId) || pinLayers[0];
          customPins = activePinLayer.pins || [];
          clearCustomPinMarkers();
          loadPinsToMap();
          updateLayerSelectMenu();
          updatePinListMenu();
        });
      }
      loadPinLayersFromDatabase();
      
      function clearCustomPinMarkers() {
        customPinLayer.clearLayers();
        customPinMarkers = {};
      }
      
      /* Layer Selection UI */
      function updateLayerSelectMenu() {
        const select = document.getElementById("pinLayerSelect");
        select.innerHTML = "";
        let sortedLayers = pinLayers.slice().sort((a, b) => a.name.localeCompare(b.name));
        sortedLayers.forEach(layer => {
          const opt = document.createElement("option");
          opt.value = layer.id;
          opt.textContent = layer.name;
          if (layer.id === activePinLayerId) {
            opt.selected = true;
          }
          select.appendChild(opt);
        });
        const optNew = document.createElement("option");
        optNew.value = "create_new";
        optNew.textContent = "+";
        select.appendChild(optNew);
      }
      updateLayerSelectMenu();
      
      document.getElementById("pinLayerSelect").addEventListener("change", function(e) {
        if (e.target.value === "create_new") {
          const layerName = prompt("Enter new layer name:");
          if (layerName) {
            const newLayerId = "layer_" + Date.now();
            const newLayer = { id: newLayerId, name: layerName, pins: [] };
            pinLayers.push(newLayer);
            activePinLayerId = newLayerId;
            activePinLayer = newLayer;
            savePinLayersToDatabase();
            updateLayerSelectMenu();
            clearCustomPinMarkers();
            customPins = activePinLayer.pins;
            loadPinsToMap();
            showNotification("New layer created", "success");
          } else {
            document.getElementById("pinLayerSelect").value = activePinLayerId;
          }
        } else {
          activePinLayerId = e.target.value;
          activePinLayer = pinLayers.find(layer => layer.id === activePinLayerId);
          clearCustomPinMarkers();
          customPins = activePinLayer.pins;
          loadPinsToMap();
        }
      });
      
      document.getElementById("renameLayerBtn").addEventListener("click", function() {
        const newName = prompt("Enter new name for the current layer:", activePinLayer.name);
        if (newName) {
          activePinLayer.name = newName;
          savePinLayersToDatabase();
          updateLayerSelectMenu();
        }
      });
      
      document.getElementById("exportLayerBtn").addEventListener("click", async function() {
        try {
          const dataStr = JSON.stringify({ pins: activePinLayer.pins }, null, 4);
          const fileName = activePinLayer.name.replace(/\s+/g, "_") + ".json";
          await saveFile(dataStr, fileName);
        } catch (err) {
          console.error(err);
          alert("Error saving file: " + err);
        }
      });
      
      document.getElementById("importLayerBtn").addEventListener("click", function() {
        document.getElementById("importLayerInput").click();
      });
      document.getElementById("importLayerInput").addEventListener("change", function(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            const importedData = JSON.parse(e.target.result);
            const importedPins = importedData.pins ? importedData.pins : importedData;
            if (!activePinLayer) {
              throw new Error("No active layer available.");
            }
            if (!activePinLayer.pins) {
              activePinLayer.pins = [];
            }
            if (Array.isArray(importedPins)) {
              importedPins.forEach(pin => {
                if (typeof pin.tooltipOpened === "undefined") {
                  pin.tooltipOpened = true;
                }
                if (activePinLayer.pins.find(item => item.id === pin.id)) {
                  pin.id = "pin_" + Date.now() + "_" + Math.floor(Math.random() * 1000);
                }
                activePinLayer.pins.push(pin);
              });
              savePinLayersToDatabase();
              clearCustomPinMarkers();
              loadPinsToMap();
              showNotification("Pins imported successfully", "success");
            } else {
              throw new Error("Invalid file format. Expected an object with a 'pins' array.");
            }
          } catch (ex) {
            alert("Error importing file: " + ex.message);
          }
        };
        reader.readAsText(file);
        e.target.value = "";
      });
      
      document.getElementById("deleteLayerBtn").addEventListener("click", function() {
        if (confirm("Jesi li siguran?")) {
          if (pinLayers.length === 1) {
            alert("Cannot delete the only layer.");
            return;
          }
          pinLayers = pinLayers.filter(layer => layer.id !== activePinLayerId);
          activePinLayer = pinLayers[0];
          activePinLayerId = activePinLayer.id;
          customPins = activePinLayer.pins;
          savePinLayersToDatabase();
          updateLayerSelectMenu();
          clearCustomPinMarkers();
          loadPinsToMap();
          showNotification("Layer deleted", "success");
        }
      });
      
      /***** Custom Pin Functionality *****/
      let customPinMarkers = {};
      
      function lightenColor(hex, percent) {
        const num = parseInt(hex.replace("#", ""), 16);
        const amt = Math.round(2.55 * percent);
        let R = (num >> 16) + amt;
        let G = ((num >> 8) & 0x00FF) + amt;
        let B = (num & 0x0000FF) + amt;
        return "#" + (0x1000000 + (R < 255 ? (R < 0 ? 0 : R) : 255) * 0x10000 +
          (G < 255 ? (G < 0 ? 0 : G) : 255) * 0x100 +
          (B < 255 ? (B < 0 ? 0 : B) : 255))
          .toString(16).slice(1);
      }
      function darkenColor(hex, percent) {
        return lightenColor(hex, -percent);
      }
      function parseIconValue(value) {
        const parts = value.split("-");
        return { color: parts[0], shape: parts[1] };
      }
      
      function getMarkerSize() {
        const baseSize = 20;
        const zoomDiff = map.getZoom() - 13;
        const factor = 1.0366;
        return baseSize * Math.pow(factor, zoomDiff);
      }
      
      function createMarkerIcon(iconData, pinNumber) {
        const size = getMarkerSize();
        const lighter = lightenColor(iconData.color, 20);
        const darker = darkenColor(iconData.color, 20);
        let inlineStyle = "background: " + iconData.color + "; background-image: linear-gradient(135deg, " 
                        + lighter + ", " + darker + "); width:" + size + "px; height:" + size 
                        + "px; line-height:" + size + "px; text-align:center;";
        if (iconData.shape === "circle") {
          inlineStyle += "border-radius:" + (size / 2) + "px;";
        }
        const htmlContent = '<div class="custom-marker" style="' + inlineStyle + '">' + (pinNumber || "") + "</div>";
        return L.divIcon({
          html: htmlContent,
          iconSize: [size, size],
          iconAnchor: [size / 2, size]
        });
      }
      
      function createPinMarker(pin) {
        let iconData = parseIconValue(pin.icon);
        if (iconData.shape === "triangle") {
          iconData.shape = "circle";
        }
        const divIcon = createMarkerIcon(iconData, pin.number);
        const marker = L.marker([pin.lat, pin.lng], { icon: divIcon, draggable: true });
        marker.pinData = pin;
        marker.on("dragend", function(e) {
          const newLatLng = e.target.getLatLng();
          const foundPin = customPins.find(item => item.id === pin.id);
          if (foundPin) {
            foundPin.lat = newLatLng.lat;
            foundPin.lng = newLatLng.lng;
            savePinLayersToDatabase();
            updateTooltipPositions();
          }
        });
        marker.on("click", function() {
          togglePinTooltip(pin.id);
        });
        marker.on("contextmenu", function(e) {
          e.originalEvent.preventDefault();
          showContextMenu(pin.id, e.latlng);
        });
        if (pin.tooltipOpened) {
          const infoHtml = '<div style="text-align:left;"><strong>' + pin.title + '</strong><br/>' + pin.description + '</div>';
          marker.bindTooltip(infoHtml, { permanent: true, direction: "right", offset: L.point(3, 5), className: "custom-tooltip" });
          marker.infoVisible = true;
          marker.originalTooltipContent = infoHtml;
        } else {
          marker.infoVisible = false;
        }
        customPinMarkers[pin.id] = marker;
        customPinLayer.addLayer(marker);
        updateTooltipPositions();
      }
      
      function updateAllMarkerIcons() {
        for (const key in customPinMarkers) {
          const marker = customPinMarkers[key];
          const pin = marker.pinData;
          let iconData = parseIconValue(pin.icon);
          if (iconData.shape === "triangle") iconData.shape = "circle";
          const newIcon = createMarkerIcon(iconData, pin.number);
          marker.setIcon(newIcon);
        }
      }
      
      function loadPinsToMap() {
        if (!customPins || !Array.isArray(customPins)) {
          customPins = [];
        }
        customPins.forEach(pin => {
          createPinMarker(pin);
        });
        updatePinListMenu();
      }
      loadPinsToMap();
      
      map.on("zoomend moveend", function() {
        updateAllMarkerIcons();
        updateTooltipPositions();
      });
      
      /* SEARCH BAR FUNCTIONALITY */
      const searchBar = document.getElementById("searchBar");
      const searchResults = document.getElementById("searchResults");
      
      searchBar.addEventListener("keyup", debounce(function(e) {
        const query = searchBar.value.trim();
        if (query.length < 3) {
          searchResults.style.display = "none";
          return;
        }
        fetch("https://nominatim.openstreetmap.org/search?format=json&limit=5&q=" + encodeURIComponent(query))
          .then(response => response.json())
          .then(data => {
            searchResults.innerHTML = "";
            if (data.length > 0) {
              data.forEach(result => {
                const li = document.createElement("li");
                li.textContent = result.display_name;
                li.addEventListener("click", function() {
                  const lat = parseFloat(result.lat);
                  const lon = parseFloat(result.lon);
                  map.setView([lat, lon], 8);
                  searchBar.value = "";
                  searchResults.innerHTML = "";
                  searchResults.style.display = "none";
                });
                searchResults.appendChild(li);
              });
              searchResults.style.display = "block";
            } else {
              searchResults.style.display = "none";
            }
          })
          .catch(error => {
            console.error(error);
            searchResults.style.display = "none";
          });
      }, 300));
      
      searchBar.addEventListener("keydown", function(e) {
        if (e.key === "Enter") {
          e.preventDefault();
          if (searchResults.firstChild) {
            searchResults.firstChild.click();
          }
          searchBar.value = "";
          searchResults.innerHTML = "";
          searchResults.style.display = "none";
        }
      });
      
      /* Update Pin List */
      function updatePinListMenu() {
        const content = document.getElementById("pinListContent");
        const sortedPins = customPins.slice().sort((a, b) => {
          let aNum = parseFloat(a.number),
              bNum = parseFloat(b.number);
          if (!isNaN(aNum) && !isNaN(bNum)) {
            if (aNum !== bNum) return aNum - bNum;
          } else {
            if (a.number < b.number) return -1;
            if (a.number > b.number) return 1;
          }
          if (a.title < b.title) return -1;
          if (a.title > b.title) return 1;
          if (a.description < b.description) return -1;
          if (a.description > b.description) return 1;
          return 0;
        });
        let html = "";
        sortedPins.forEach(pin => {
          const textStyle = pin.tooltipOpened ? "" : "text-decoration: line-through;";
          const iconData = parseIconValue(pin.icon);
          const size = 15;
          const lighter = lightenColor(iconData.color, 20);
          const darker = darkenColor(iconData.color, 20);
          let iconHtml = '<div class="pin-icon-number" style="background:' + iconData.color +
                         '; background-image: linear-gradient(135deg, ' + lighter + ', ' + darker + ');';
          if (iconData.shape === "circle") {
            iconHtml += "border-radius:" + (size / 2) + "px;";
          }
          iconHtml += '">' + (pin.number || "") + '</div>';
          const textContent = '<span class="pin-text" style="' + textStyle + '">' + pin.title + (pin.description ? ' - ' + pin.description : '') + '</span>';
          html += '<div class="pin-list-item">' + iconHtml + textContent + '</div>';
        });
        content.innerHTML = html;
      }
      
      /* Toggle all pin tooltips */
      document.getElementById("toggleAllUtovare").addEventListener("click", function() {
        for (let id in customPinMarkers) {
          const marker = customPinMarkers[id];
          const pin = marker.pinData;
          if (!marker.infoVisible) {
            const infoHtml = '<div style="text-align:left;"><strong>' + pin.title + '</strong><br/>' + pin.description + '</div>';
            marker.bindTooltip(infoHtml, { permanent: true, direction: "right", offset: L.point(3,5), className: "custom-tooltip" });
            marker.infoVisible = true;
            pin.tooltipOpened = true;
          }
        }
        updatePinListMenu();
        updateTooltipPositions();
      });
      
      function updateTooltipPositions() {
        const visibleMarkers = [];
        for (const key in customPinMarkers) {
          const marker = customPinMarkers[key];
          if (marker.infoVisible && marker.getTooltip()) {
            visibleMarkers.push(marker);
          }
        }
        const tooltips = [];
        visibleMarkers.forEach(marker => {
          const defaultOffset = L.point(13, -7);
          const content = marker.getTooltip().getContent();
          marker.unbindTooltip();
          marker.bindTooltip(content, { permanent: true, direction: "right", offset: defaultOffset, className: "custom-tooltip" });
          marker.openTooltip();
          const tooltipElement = marker.getTooltip().getElement();
          if (tooltipElement) {
            tooltips.push({ marker: marker, offset: defaultOffset, rect: tooltipElement.getBoundingClientRect() });
          }
        });
        function rectsOverlap(rect1, rect2) {
          return !(rect1.right < rect2.left || rect1.left > rect2.right || rect1.bottom < rect2.top || rect1.top > rect2.bottom);
        }
        let collisionResolved = false;
        let maxIterations = 10;
        let iteration = 0;
        while (!collisionResolved && iteration < maxIterations) {
          collisionResolved = true;
          iteration++;
          for (let i = 0; i < tooltips.length; i++) {
            for (let j = i + 1; j < tooltips.length; j++) {
              if (rectsOverlap(tooltips[i].rect, tooltips[j].rect)) {
                const rectA = tooltips[i].rect;
                const rectB = tooltips[j].rect;
                const centerA = { x: rectA.left + rectA.width / 2, y: rectA.top + rectA.height / 2 };
                const centerB = { x: rectB.left + rectB.width / 2, y: rectB.top + rectB.height / 2 };
                let dx = centerB.x - centerA.x;
                let dy = centerB.y - centerA.y;
                if (dx === 0 && dy === 0) {
                  dx = 5;
                  dy = 5;
                }
                const dist = Math.sqrt(dx * dx + dy * dy);
                const shiftStep = 10;
                const shiftX = (dx / dist) * shiftStep;
                const shiftY = (dy / dist) * shiftStep;
                tooltips[j].offset = L.point(tooltips[j].offset.x + shiftX, tooltips[j].offset.y + shiftY);
                const content = tooltips[j].marker.getTooltip().getContent();
                tooltips[j].marker.unbindTooltip();
                tooltips[j].marker.bindTooltip(content, { permanent: true, direction: "right", offset: tooltips[j].offset, className: "custom-tooltip" });
                tooltips[j].marker.openTooltip();
                const newRect = tooltips[j].marker.getTooltip().getElement().getBoundingClientRect();
                tooltips[j].rect = newRect;
                collisionResolved = false;
              }
            }
          }
        }
      }
      
      function togglePinTooltip(pinId) {
        const marker = customPinMarkers[pinId];
        if (!marker) return;
        const pin = customPins.find(p => p.id === pinId);
        if (!pin) return;
        if (marker.infoVisible) {
          marker.unbindTooltip();
          marker.infoVisible = false;
          pin.tooltipOpened = false;
          savePinLayersToDatabase();
        } else {
          const infoHtml = '<div style="text-align:left;"><strong>' + pin.title + '</strong><br/>' + pin.description + '</div>';
          marker.bindTooltip(infoHtml, { permanent: true, direction: "right", offset: L.point(3,5), className: "custom-tooltip" });
          marker.infoVisible = true;
          pin.tooltipOpened = true;
          marker.originalTooltipContent = infoHtml;
          savePinLayersToDatabase();
        }
        updateTooltipPositions();
        updatePinListMenu();
      }
      
      function showContextMenu(pinId, latlng) {
        const popup = L.popup({ offset: L.point(0, -30) })
          .setLatLng(latlng)
          .setContent(
            '<div class="custom-context-menu">' +
              '<a href="#" onclick="editPin(\'' + pinId + '\'); return false;">Izmeni</a>' +
              '<a href="#" onclick="deletePin(\'' + pinId + '\'); return false;">Obriši</a>' +
            '</div>'
          );
        popup.openOn(map);
      }
      
      window.deletePin = function(pinId) {
        if (customPinMarkers[pinId]) {
          customPinLayer.removeLayer(customPinMarkers[pinId]);
          delete customPinMarkers[pinId];
        }
        removeCustomPin(pinId);
        map.closePopup();
        updateTooltipPositions();
        updatePinListMenu();
      };
      
      function removeCustomPin(pinId) {
        activePinLayer.pins = activePinLayer.pins.filter(pin => pin.id !== pinId);
        customPins = activePinLayer.pins;
        savePinLayersToDatabase();
      }
      
      window.editPin = function(pinId) {
        const pin = customPins.find(item => item.id === pinId);
        if (pin) {
          currentEditingPinId = pinId;
          document.getElementById("modalHeader").textContent = "Edit Custom Pin";
          document.getElementById("pinTitle").value = pin.title;
          document.getElementById("pinNumber").value = pin.number;
          document.getElementById("pinDescription").value = pin.description;
          const parts = pin.icon.split("-");
          updateSelectedIconChoices(parts[1], parts[0]);
          const tableHTML = generateColorTable();
          document.getElementById("colorSelection").innerHTML = tableHTML;
          document.querySelectorAll("#colorSelection .color-option").forEach(el => {
            el.addEventListener("click", function() {
              const c = this.getAttribute("data-color");
              updateSelectedIconChoices(selectedShape, c);
            });
          });
          document.getElementById("pinFormModal").style.display = "flex";
        }
      };
      
      let currentEditingPinId = null;
      let currentPinLatLng = null;
      map.on("contextmenu", function(e) {
        currentPinLatLng = e.latlng;
        currentEditingPinId = null;
        document.getElementById("modalHeader").textContent = "";
        showPinForm();
      });
      
      /***** Icon Selection Functions *****/
      let selectedShape = "circle";
      let selectedColor = "blue";
      function updatePreview() {
        const previewWindow = document.getElementById("previewWindow");
        const lighter = lightenColor(selectedColor, 20);
        const darker = darkenColor(selectedColor, 20);
        let style = "background: " + selectedColor + "; background-image: linear-gradient(135deg, " 
                  + lighter + ", " + darker + "); width:100px; height:100px; line-height:100px;";
        if (selectedShape === "circle") {
          style += "border-radius:50%;";
        }
        previewWindow.innerHTML = '<div class="custom-marker" style="' + style + '"></div>';
      }
      function updateSelectedIconChoices(shape, color) {
        document.querySelectorAll("#shapeSelection .shape-option").forEach(el => {
          el.classList.remove("selected");
          if (el.getAttribute("data-shape") === shape) {
            el.classList.add("selected");
          }
        });
        document.querySelectorAll("#colorSelection .color-option").forEach(el => {
          el.classList.remove("selected");
          if (el.getAttribute("data-color") === color) {
            el.classList.add("selected");
          }
        });
        selectedShape = shape;
        selectedColor = color;
        updatePreview();
      }
      document.querySelectorAll("#shapeSelection .shape-option").forEach(el => {
        el.addEventListener("click", function() {
          const shape = this.getAttribute("data-shape");
          updateSelectedIconChoices(shape, selectedColor);
        });
      });
      function hslToHex(h, s, l) {
        s /= 100;
        l /= 100;
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - c / 2;
        let r = 0, g = 0, b = 0;
        if (0 <= h && h < 60) { r = c; g = x; b = 0; }
        else if (60 <= h && h < 120) { r = x; g = c; b = 0; }
        else if (120 <= h && h < 180) { r = 0; g = c; b = x; }
        else if (180 <= h && h < 240) { r = 0; g = x; b = c; }
        else if (240 <= h && h < 300) { r = x; g = 0; b = c; }
        else if (300 <= h && h < 360) { r = c; g = 0; b = x; }
        r = Math.round((r + m) * 255);
        g = Math.round((g + m) * 255);
        b = Math.round((b + m) * 255);
        return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
      }
      function generateColorTable() {
        let totalCells = 5 * 9;
        let html = "<table>";
        for (let i = 0; i < 5; i++) {
          html += "<tr>";
          for (let j = 0; j < 9; j++) {
            let index = i * 9 + j;
            let hue = (index * 360) / totalCells;
            let color = hslToHex(hue, 100, 50);
            html += "<td><div class='color-option' data-color='" + color +
                    "' style='width:15px; height:15px; background:" + color +
                    "; border:1px solid #ccc;'></div></td>";
          }
          html += "</tr>";
        }
        html += "</table>";
        return html;
      }
      function showPinForm() {
        document.getElementById("pinFormModal").style.display = "flex";
        document.getElementById("pinTitle").value = "";
        document.getElementById("pinNumber").value = "";
        document.getElementById("pinDescription").value = "";
        updateSelectedIconChoices("circle", "blue");
        const tableHTML = generateColorTable();
        document.getElementById("colorSelection").innerHTML = tableHTML;
        document.querySelectorAll("#colorSelection .color-option").forEach(el => {
          el.addEventListener("click", function() {
            const c = this.getAttribute("data-color");
            updateSelectedIconChoices(selectedShape, c);
          });
        });
      }
      function hidePinForm() {
        document.getElementById("pinFormModal").style.display = "none";
      }
      document.getElementById("savePinBtn").addEventListener("click", function() {
        const title = document.getElementById("pinTitle").value.trim();
        const number = document.getElementById("pinNumber").value.trim();
        const description = document.getElementById("pinDescription").value.trim();
        if (!title) {
          alert("Title is required!");
          return;
        }
        if (!currentEditingPinId && !currentPinLatLng) {
          alert("No location selected. Please right-click on the map to choose a location.");
          return;
        }
        if (!activePinLayer) {
          alert("No active layer available. Please reload the page.");
          return;
        }
        const iconType = selectedColor + "-" + selectedShape;
        if (currentEditingPinId) {
          const pin = customPins.find(item => item.id === currentEditingPinId);
          if (pin) {
            pin.title = title;
            pin.number = number;
            pin.description = description;
            pin.icon = iconType;
            savePinLayersToDatabase();
            if (customPinMarkers[currentEditingPinId]) {
              customPinLayer.removeLayer(customPinMarkers[currentEditingPinId]);
              delete customPinMarkers[currentEditingPinId];
            }
            createPinMarker(pin);
          }
          currentEditingPinId = null;
        } else {
          const pinId = "pin_" + Date.now();
          const pinObj = {
            id: pinId,
            lat: currentPinLatLng.lat,
            lng: currentPinLatLng.lng,
            title: title,
            number: number,
            description: description,
            icon: iconType,
            tooltipOpened: true
          };
          if (!activePinLayer.pins) {
            activePinLayer.pins = [];
          }
          activePinLayer.pins.push(pinObj);
          savePinLayersToDatabase();
          createPinMarker(pinObj);
        }
        hidePinForm();
        updatePinListMenu();
      });
      document.getElementById("cancelPinBtn").addEventListener("click", function() {
        hidePinForm();
      });
    } // End initMapAndRealtime
  </script>
  
  <!-- DOMContentLoaded block for Resizer functionality -->
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      const pinList = document.getElementById("pinListMenu");
      const resizer = document.getElementById("pinListResizer");
      resizer.style.pointerEvents = "all";
      
      let startX, startWidth;
      const initialWidth = pinList.offsetWidth;
      const minWidth = initialWidth * 0.5;
      const maxWidth = initialWidth * 2;
      
      resizer.addEventListener("mousedown", function(e) {
        e.preventDefault();
        startX = e.clientX;
        startWidth = pinList.offsetWidth;
        document.documentElement.addEventListener("mousemove", doDrag, false);
        document.documentElement.addEventListener("mouseup", stopDrag, false);
      }, false);
      
      function doDrag(e) {
        const diffX = e.clientX - startX;
        let newWidth = startWidth + diffX;
        if (newWidth < minWidth) newWidth = minWidth;
        if (newWidth > maxWidth) newWidth = maxWidth;
        pinList.style.width = newWidth + "px";
      }
      
      function stopDrag(e) {
        document.documentElement.removeEventListener("mousemove", doDrag, false);
        document.documentElement.removeEventListener("mouseup", stopDrag, false);
      }
      
      // On double-click, auto-adjust the width based on widest pin text
      resizer.addEventListener("dblclick", function(e) {
        const listItems = document.querySelectorAll("#pinListContent .pin-text");
        let maxContentWidth = 0;
        listItems.forEach(item => {
          const clone = item.cloneNode(true);
          clone.style.visibility = "hidden";
          clone.style.whiteSpace = "nowrap";
          clone.style.position = "absolute";
          document.body.appendChild(clone);
          const width = clone.offsetWidth;
          if (width > maxContentWidth) maxContentWidth = width;
          document.body.removeChild(clone);
        });
        const extraSpace = 40;
        let newWidth = maxContentWidth + extraSpace;
        if (newWidth < minWidth) newWidth = minWidth;
        if (newWidth > maxWidth) newWidth = maxWidth;
        pinList.style.width = newWidth + "px";
      }, false);
    });
  </script>
</body>
</html>
